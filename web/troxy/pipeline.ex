defmodule Davo.Troxy.Pipeline do
  require Logger
  use Plug.Builder

  plug :rewrite_composed_host
  plug :rewrite_troxy_host_header
  plug :skip_self_peer # And let the normal phoenix router handle the conn
  plug :assign_room_from_proxy_authorization
  # plug :skip_self_hosts
  # plug :cookies # Support upstream cookies
  # plug :inject_js # inject custom js
  # plug :disable_js # disable js scripts
  # plug :non_authoritative_info # send 203 responses instead of 200 if content is modified

  # plug :plug_uri

  plug Plug.RequestId
  plug :assign_request_id
  plug :remove_req_headers
  use Troxy.Interfaces.Plug
  plug :remove_resp_headers

  ########################
  # TODO: Move to its own package.
  # Or implement the URI protocol for Plug.Conn
  ########################

  # def plug_uri(conn, _opts) do
  #   # No need to add `authority` as it can be extracted from the other data
  #   uri = %URI{fragment: term, host: term,
  #              path: term, port: term, query: term, scheme: term, userinfo: term}

  #   %Plug.Conn{port: 80, scheme: :https,  method: "GET", host: "github.com", request_path: "/davoclavo", assigns: %{id: "code"}, req_headers: [{"accept", "text/html"}], resp_headers: [{"content-type", "text/html; charset=utf8"}], status: 200},
  #   conn
  #   |> assign(:uri, uri)
  # end


  ########################
  # TODO: Move these to Troxy.Interfaces.
  # Troxy helper functions
  ########################

  # If the request has a "proxy-authorization" header, it then assigns
  # the user as the connection "room", and ignores the password
  def assign_room_from_proxy_authorization(conn, _opts) do
    case Plug.Conn.get_req_header(conn, "proxy-authorization") do
      ["Basic " <> encoded_auth] ->
        room = Base.decode64!(encoded_auth)
        |> String.split(":")
        |> hd

        conn
        |> Plug.Conn.delete_req_header("proxy-authorization")
        |> Plug.Conn.assign(:room, room)
      _ ->
        conn
        |> Plug.Conn.assign(:room, "lobby") # Lobby
    end
  end

  # Assigns the id generated by Plug.RequestId for easier access
  def assign_request_id(conn, _opts) do
    [conn_id] = Plug.Conn.get_resp_header(conn, "x-request-id")
    Plug.Conn.assign(conn, :id, conn_id)
  end

  # If the request has a "x-troxy-host" header
  def rewrite_troxy_host_header(conn, _opts) do
    case Plug.Conn.get_req_header(conn, "x-troxy-host") do
      [] ->
        conn
      [target_host] ->
        # Added the peer to temporarily allow requests from the ui
        %Plug.Conn{conn | host: target_host, peer: {{127,0,0,2}, 111317}}
        |> delete_req_header("x-troxy-host")
        |> delete_req_header("host")
        |> put_req_header("host", target_host)
    end
  end


  # Transforms github.com.troxy.davo.io/davoclavo/troxy_server -> github.com/davoclavo/troxy_server
  def rewrite_composed_host(conn, _opts) do
    host_header = Plug.Conn.get_req_header(conn, "host") |> hd
    case Regex.named_captures(~r/(?<target_host>.*)(?<host>#{get_public_host}(:\d+)?)/, host_header) do
      %{"host" => host, "target_host" => target_host} ->
        case String.length(target_host) do
          0 ->
            conn
          _ ->
            # TODO: Fix regex to remove rightmost "."
            target_host = String.rstrip(target_host, ?.)
            conn
            |> delete_req_header("host")
            |> put_req_header("host", target_host)
        end
      nil ->
        # No regexp match means it is a normal host header
        conn
    end
  end

  def skip_self_peer(conn, _opts) do
    [get_public_ip, get_local_ips]
    |> Enum.any?(&(&1 == (conn.peer |> Tuple.to_list |> hd |> Tuple.to_list |> Enum.join("."))))
    |> if do
      Logger.info("Skip Troxy because of peer")
      Plug.Conn.put_private(conn, :plug_skip_troxy, true)
    else
      conn
    end
  end

  def skip_self_hosts(conn, _opts) do
    # TODO: Use URI.parse for the port and subdomains
    loopback_hosts
    # This proxies to other ports as well
    # host_header = Plug.Conn.get_req_header(conn, "host") |> hd
    # |> Enum.any?(&(&1 == host_header))
    # This only matches to the the host without port
    |> Enum.any?(&(&1 == conn.host))
    |> if do
         Logger.info("Skip Troxy because of host")
         Plug.Conn.put_private(conn, :plug_skip_troxy, true)
       else
         conn
       end
  end

  def loopback_hosts do
    get_local_ips
    |> Enum.concat([get_public_host])
    |> Enum.concat(["localhost"])
  end

  def get_local_ips do
    {:ok, local_ips} = :inet.getif
    local_ips
    |> Enum.map(fn ip_record ->
      # Example: {{192, 168, 99, 1}, {192, 168, 99, 255}, {255, 255, 255, 0}}
      ip_record
      |> Tuple.to_list
      |> hd
      |> Tuple.to_list
      |> Enum.join(".")
    end)
  end

  def get_public_ip do
    Application.get_env(:davo, Davo.Endpoint)[:url][:ip]
  end

  def get_public_host do
    Application.get_env(:davo, Davo.Endpoint)[:url][:host]
  end

  def remove_req_headers(conn, _opts) do
    conn
  end

  def remove_resp_headers(conn, _opts) do
    conn
    |> Plug.Conn.delete_resp_header("x-request-id") # Added by Plug.RequestId
    |> Plug.Conn.delete_resp_header("cache-control") # Added by some Plug
  end

  # SSL - http://www.phoenixframework.org/v1.0.0/docs/configuration-for-ssl

  # http://stackoverflow.com/questions/12994611/relative-urls-in-a-proxied-website-dont-work
  defp add_base_url(host, body) do
    Regex.replace(~r/<head>/, body, ~s(<head><base href="#{host}" />))
  end


  ##########################
  # Troxy in-module handlers
  ##########################

  @topic "users:lobby"

  def req_handler(conn) do
    Logger.info("Request proxied")
    req_headers = Enum.into(conn.req_headers, %{})
    msg = conn
    |> Map.take([:scheme, :host, :port, :method, :request_path, :query_string, :assigns])
    |> Map.merge(%{req_headers: req_headers})
    |> Map.merge(%{conn_id: conn.assigns.id,
                   room: conn.assigns.room})

    # Is broadcast async?? if not, I think it should
    Davo.Endpoint.broadcast(@topic, "conn:req", msg)
    conn
  end

  def req_body_handler(conn, body_chunk, more_body) do
    Logger.info("Request body chunk")
    encoded_body_chunk = Base.encode64(body_chunk)
    msg = %{
      room: conn.assigns.room,
      conn_id: conn.assigns.id,
      body_chunk: encoded_body_chunk,
      more_body: more_body
    }
    Davo.Endpoint.broadcast(@topic, "conn:req_body_chunk", msg)
    conn
  end

  def resp_handler(conn) do
    Logger.info("Response proxied")
    resp_headers = Enum.into(conn.resp_headers, %{})
    msg = %{
      room: conn.assigns.room,
      conn_id: conn.assigns.id,
      status: conn.status,
      resp_headers: resp_headers
    }
    Davo.Endpoint.broadcast(@topic, "conn:resp", msg)
    conn
  end

  def resp_body_handler(conn, body_chunk, more_body) do
    Logger.info("Response body chunk")
    encoded_body_chunk = Base.encode64(body_chunk)
    msg = %{
      room: conn.assigns.room,
      conn_id: conn.assigns.id,
      body_chunk: encoded_body_chunk,
      more_body: more_body
    }
    Davo.Endpoint.broadcast(@topic, "conn:resp_body_chunk", msg)
    conn
  end

  def broadcast_conn(conn) do
    Davo.Endpoint.broadcast(@topic, "conn:req", conn)
  end
end

defimpl Poison.Encoder, for: Plug.Conn do
  def encode(conn, options) do
    # peer = conn.peer

    # TODO: Treat proplists as arrays to preserve order
    # kwlists to maps to be able to JSON encodify easily
    req_headers = Enum.into(conn.req_headers, %{})

    conn
    |> Map.take([:scheme, :host, :port, :method, :request_path, :query_string, :assigns])
    |> Map.merge(%{req_headers: req_headers})
    |> Poison.encode!
  end
end
